<html>
<head>
	<title>The Night Watch Level Editor</title>
	<meta charset="UTF-8">
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="https://d3js.org/d3-drag.v1.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Inconsolata&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Montserrat:200,200i&display=swap" rel="stylesheet">
</head>
<body bgcolor="#f8f8f8" style="text-align: center;">
	<h3 style="font-family: Montserrat;">Welcome to Version 1.4 ðŸŽ‰ðŸŽ‰</h3>
	<div style="font-family: Lato; display:flex; justify-content: center; margin-top: 50px">
		<label style="margin-right: 20px;" for="width">Width: </label>
		<input value="1280" style="border-radius: 10px" type="number" id="width"><br><br>
		<label style="margin-left: 40px; margin-right: 20px;" for="height">Height: </label>
		<input value="720" style="border-radius: 10px" type="number" id="height"><br><br>
		<label style="margin-left: 40px; margin-right: 20px;" for="tile">Tile Size: </label>
		<input value="30" style="border-radius: 10px" type="number" id="tile"><br><br>
	</div>
	<div style="font-family: Lato; display:flex; justify-content: center; margin-top: 50; margin-bottom: 50">
		<label style="margin-right: 20px;" for="guards">Num of Guards: </label>
		<input value="0" style="border-radius: 10px" type="number" id="guards"><br><br>
		<label style="margin-left: 40px; margin-right: 20px;" for="traps">Num of Traps: </label>
		<input value="0" style="border-radius: 10px" type="number" id="traps"><br><br>
	</div>
	<p style="font-family: Lato; text-align: left;margin: 0 auto; width: 1000;"><b>Several notes:</b> 
	<br/>1. Please don't input values that will force the svg to overfill. If you do, the web app will crash :( 
	<br/>2. Don't change the tile size unless you <i>really</i> have to. 
	<br/>3. Coordinates are recorded in real life so it's important to draw the paths without skips on the grid.
	<br/>4. Tiles change back to white when a path is erased, even if there was another path drawn beneath it. Dw the "backend" is correct - I was just too lazy to fix this bug.</p>
	<svg height="900" width="1100" class="mainGrid"/>
	<script>

		let svgHeight = 900;
		let svgWidth = 1100;
		let gameWidth = 1280;
		let gameHeight = 720;
		let gameTileSize = 30;
		let numGridWidth = Math.floor(gameWidth/gameTileSize);
		let numGridHeight = gameHeight/gameTileSize;
		let tileSize = 25;
		let selectedToggle = "";
		let grid = [];
		let isDragging = false;

		let startingX = (svgWidth - numGridWidth*tileSize)/2;

		let wallColor = "#A7333F";
		let doorColor = "#FFB959";
		let thiefColor = "#82AAB5";
		let whiteColor = "#ffffff";
		let greyColor = "#cdcdcd";
		let paintColor = "#D4A0A7";

		let maxThiefPaths = 20;

		let wallRgb = "rgb(167, 51, 63)";
		let doorRgb = "rgb(255, 185, 89)";
		let thiefRgb = "rgb(130, 170, 181)";
		let paintRgb = "rgb(212, 160, 167)";
		let whiteRgb = "rgb(255, 255, 255)";

		let isNewThief = false;
		let tempThievesList = [];
		let wallList = [];
		let doorList = [];
		let thiefList = [];
		let paintingList = [];
		let undoStack = [];


		let toggleColor = {"wall": wallColor, "door": doorColor, "thief": thiefColor, "statue": paintColor};

		function createToggleButton() {
			var keys = ["wall", "door", "thief", "statue"];
			var buttonSize = 100;
			var spaceBetweenButtons = 30;
			var startingButtonX = (svgWidth - (buttonSize*keys.length + spaceBetweenButtons*(keys.length-1)))/2;

			var gridSvg = d3.select(".mainGrid");

			// add button types 
			gridSvg.selectAll(".toggle")
	   			.data(keys)
	   			.enter()
	   			.append("rect")
				.attr("class", "toggle")
				.attr("id", function(d) {return "toggle_"+d})
				.attr("x", function(d, i) {
					return startingButtonX+130*i;
				}).attr("y", 50)
				.attr("rx", 15)
				.attr("width", 100)
				.attr("height", 50)
				.style("stroke", "black")
				.style("fill", whiteColor)
				.on("click", function(d, i) {
					selectedToggle = d;

					d3.selectAll(".toggle")
						.transition()
						.duration(50)
						.style("fill", whiteColor);
					d3.select("#toggle_"+d)
						.transition()
						.duration(100)
						.style("fill", toggleColor[d]);

					isDragging = false;

				});


			for (var i = 0; i < keys.length; i++) {
				gridSvg.append("text")
					.attr("x", (startingButtonX+130*i)+50)
					.attr("y", 80)
					.style("text-anchor", "middle")
					.style("font-family", "Lato")
					.style("font-color", "black")
					.text(keys[i]);
			}

			// add reset button
			gridSvg.append("rect")
				.attr("x", startingX)
				.attr("y", 50)
				.attr("width", 100)
				.attr("height", 50)
				.attr("rx", 15)
				.style("stroke", "black")
				.style("fill", whiteColor)
				.on("click", function() {
					d3.selectAll(".cell").style("fill", whiteColor);
					isDragging = false;
					selectedToggle = "";
					d3.selectAll(".toggle")
						.transition()
						.duration(50)
						.style("fill", whiteColor);
					d3.selectAll(".grid_path").remove();

					fillOuterWalls();
				});
			gridSvg.append("text")
				.attr("x", startingX+buttonSize/2)
				.attr("y", 80)
				.style("text-anchor", "middle")
				.style("font-family", "Lato")
				.style("font-color", "black")
				.text("reset");

			// add export button
			gridSvg.append("rect")
				.attr("x", svgWidth-startingX-buttonSize)
				.attr("y", 50)
				.attr("width", 100)
				.attr("height", 50)
				.attr("rx", 15)
				.style("stroke", "black")
				.style("fill", whiteColor)
				.on("click", function() {
					exportFile(createFinalJson());
					isNewThief = false;
					isDragging = false;
					selectedToggle = "";
					wallList = [];
					doorList = [];
					thiefList = [];
					paintingList = [];
				});
			gridSvg.append("text")
				.attr("x", svgWidth-startingX-buttonSize/2)
				.attr("y", 80)
				.style("text-anchor", "middle")
				.style("font-family", "Lato")
				.style("font-color", "black")
				.text("export");

			// add undo button
			gridSvg.append("rect")
				.attr("x", startingX + buttonSize + spaceBetweenButtons)
				.attr("y", 50)
				.attr("width", 100)
				.attr("height", 50)
				.attr("rx", 15)
				.style("stroke", "black")
				.style("fill", whiteColor)
				.on("click", function() {
					deleteLastItem();
				});
			gridSvg.append("text")
				.attr("x", startingX + spaceBetweenButtons+buttonSize*1.5)
				.attr("y", 80)
				.style("text-anchor", "middle")
				.style("font-family", "Lato")
				.style("font-color", "black")
				.text("undo");
		}


		function createGridDS() {
			for (var i = 0; i < numGridWidth; i++) {
				for (var j = 0; j < numGridHeight; j++) {
					grid.push({"x": i, "y": j});
				}
			}
		}

		function drawGrid() {
			var gridSvg = d3.select(".mainGrid");
			
			gridSvg.selectAll(".cell").data(grid).enter()
				.append("rect")
				.attr("class", "cell")
				.attr("id", function(d) {return "cell_"+d.x+"_"+d.y})
				.attr("x", function(d) {return startingX+tileSize*Number(d.x)})
				.attr("y", function(d) {return 150+tileSize*Number(d.y)})
				.attr("width", tileSize)
				.attr("height", tileSize)
				.style("fill", whiteColor)
				.style("stroke", greyColor)
				.style("stroke-width", 2)
				.on("mousemove", function(d) {
					if (isDragging && selectedToggle != "") {
						var element = d3.select("#cell_"+d.x+"_"+d.y);

						// doors can be drawn on walls
						if (selectedToggle == "door" && (element.style("fill") == wallRgb)) {
							element.style("fill", toggleColor[selectedToggle]);
							addCoordToList(d, selectedToggle);
						} 
						// thief's paths can be drawn on other thieves' paths
						else if (selectedToggle == "thief" && element.style("fill") != wallRgb && element.style("fill") != doorRgb && element.style("fill") != paintRgb) {
							var thiefCount = thiefList.length;
							element.style("fill", d3.interpolateBlues(0.15+(thiefCount/maxThiefPaths*0.85)));
							addCoordToList(d, selectedToggle);
						} else if (element.style("fill") == whiteRgb) {
							element.style("fill", toggleColor[selectedToggle]);
							addCoordToList(d, selectedToggle);
						}
						
					}
				}).on("click", function(d) {
					isDragging = !isDragging;
					var element = d3.select("#cell_"+d.x+"_"+d.y);
					var tempX = startingX+tileSize*Number(d.x);
					var tempY = 150+tileSize*Number(d.y);

					console.log(tempX + " " + tempY);
					if (isDragging && selectedToggle != "") {
						addNewList(selectedToggle);
						undoStack.push(selectedToggle);
					}
					if (isDragging && selectedToggle == "thief") {
						//draw border for starting position of thief
						gridSvg.append("path")
							.attr("class", "grid_path")
							.style("stroke", "black")
							.style("stroke-width", 2)
							.style("fill", "none")
							.attr("d", "M" + tempX + " " + tempY 
								+ "L" + (tempX+tileSize) + " "+ tempY 
								+ "L" + (tempX+tileSize) + " " + (tempY+tileSize)
								+ "L" + (tempX) + " " + (tempY+tileSize)
								+ "L" + tempX + " " + tempY);	
					} else {
						d3.selectAll(".grid_path").remove();
					}
			});

			fillOuterWalls();
		}

		function deleteLastItem() {
			var lastItem = undoStack.pop();
			var tempList = [];
			// get last item in list
			if (lastItem == "wall") {
				tempList = wallList[wallList.length-1];
			} else if (lastItem == "door") {
				tempList = doorList[doorList.length-1];
			} else if (lastItem == "thief") {
				tempList = thiefList[thiefList.length-1]; 
			} else if (lastItem == "statue") {
				tempList = paintingList[paintingList.length-1]; 
			}

			// change the color of last path to white
			for (var i = 0; i < tempList.length; i++) {
				d3.select("#cell_" + tempList[i].x + "_" + tempList[i].y)
					.style("fill", whiteColor);
			}

			// delete last item in list
			if (lastItem == "wall") {
				wallList.pop();
			} else if (lastItem == "door") {
				doorList.pop()
			} else if (lastItem == "thief") {
				thiefList.pop();
			} else if (lastItem == "statue") {
				paintingList.pop();
			}

		}

		function addNewList(selectedToggle) {
			if (selectedToggle == "wall") {
				wallList.push([]);
			} else if (selectedToggle == "door") {
				doorList.push([]);
			} else if (selectedToggle == "thief") {
				thiefList.push([]); 
			} else if (selectedToggle == "statue") {
				paintingList.push([]); 
			}
		}

		function addCoordToList(d, selectedToggle) {
			if (selectedToggle == "wall") {
				var tempObj = {"x": d.x, "y": d.y};
				wallList[wallList.length-1].push(tempObj);
			} else if (selectedToggle == "door") {
				var tempObj = {"x": d.x, "y": d.y};
				doorList[doorList.length-1].push(tempObj);
			} else if (selectedToggle == "thief") {
				var tempObj = {"x": d.x, "y": d.y};
				thiefList[thiefList.length-1].push(tempObj);
			} else if (selectedToggle == "statue") {
				var tempObj = {"x": d.x, "y": d.y};
				paintingList[paintingList.length-1].push(tempObj);
			}
		}

		function dragstarted(d) {
			var element = d3.select("#cell_"+d.x+"_"+d.y);
		    d3.select(element).style("fill", toggleColor[selectedToggle]);
		}


	  	function dragged(d) {
	    	d3.select(d).attr("fill", toggleColor[selectedToggle]);
	    	console.log(d.x + " " + d.y);
	  	}

	  	function createFinalJson() {
	  		console.log(wallList);
	  		console.log(doorList);
	  		console.log(thiefList);
	  		console.log(document.getElementById("guards").value);
	  		var defaultJson = {
	  			"version": "1.4",
	  			"walls": wallList,
	  			"thieves": thiefList,
	  			"doors": doorList,
	  			"canvasWidth": gameWidth,
	  			"canvasHeight": gameHeight,
	  			"width": numGridWidth,
	  			"height": numGridHeight, 
	  			"tileSize": gameTileSize,
	  			"numGuards": document.getElementById("guards").value,
	  			"numTraps": document.getElementById("traps").value
	  		};

	  		// getting wall and door values 
	  		for (var i = 0; i < numGridWidth; i++) {
	  			for (var j = 0; j < numGridHeight; j++) {
	  				var element = d3.select("#cell_"+i+"_"+j);
	  				// console.log(element.style("fill"));

	  				// walls
	  				if (element.style("fill") == "rgb(167, 51, 63)") {
	  					defaultJson["walls"].push({"x": i, "y": numGridHeight-j});
	  				} 

	  			}
	  		}
	  		console.log(defaultJson);
	  		return defaultJson;
	  	}

	  	function exportFile(defaultJson) {
	  		console.log(defaultJson);
	  		var pp = document.createElement('a');
                pp.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(defaultJson)));
                pp.setAttribute('download', "thenightwatch.json");
                pp.click();
	  	}

	  	function reset() {
	  		d3.select(".mainGrid").selectAll(".cell").remove();
	  		selectedToggle = "";
			grid = [];
			isDragging = false;
			isNewThief = false;
			wallList = [];
			doorList = [];
			thiefList = [];

			d3.selectAll(".toggle")
				.transition()
				.duration(50)
				.style("fill", whiteColor);
	  	}

	  	function fillOuterWalls() {
	  		for (var i = 0; i < numGridWidth; i++) {
	  			d3.select("#cell_" + i + "_" + 0)
	  				.style("fill", wallColor);

	  			d3.select("#cell_" + i + "_" + (numGridHeight-1))
	  				.style("fill", wallColor);
	  		}

	  		for (var i = 0; i < numGridHeight; i++) {
	  			d3.select("#cell_" + 0 + "_" + i)
	  				.style("fill", wallColor);

	  			d3.select("#cell_" + (numGridWidth-1) + "_" + i)
	  				.style("fill", wallColor);
	  		}
	  	}

	  	function setDimensions() {
	  		d3.select("#width")
	  			.on("input", function() {
	  				gameWidth = this.value;
	  				numGridWidth = Math.floor(this.value/gameTileSize);
	  				startingX = (svgWidth - numGridWidth*tileSize)/2;
	  			reset();
	  			createGridDS();
	  			drawGrid();
	  		});

	  		d3.select("#height")
	  			.on("input", function() {
	  				gameHeight = this.value;
	  				numGridHeight =  Math.floor(this.value/gameTileSize);
	  			reset();
	  			createGridDS();
	  			drawGrid();
	  		});

	  		d3.select("#tile")
	  			.on("input", function() {
	  				gameTileSize = this.value;
	  				numGridWidth =  Math.floor(gameWidth/gameTileSize);
	  				numGridHeight =  Math.floor(gameHeight/gameTileSize);
	  				startingX = (svgWidth - numGridWidth*tileSize)/2;
	  			reset();
	  			window.setTimeout(createGridDS(), 5000);
	  			drawGrid();
	  		});

	  	}

	  	createGridDS();
		createToggleButton();
		drawGrid();
		setDimensions();
		
	</script>
</body>
</html>